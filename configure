#!/usr/bin/env perl

# BerylDB - A modular database.
# http://www.beryldb.com
#
# Copyright (C) 2021 Carlos F. Ferry <cferry@beryldb.com>
# 
# This file is part of BerylDB. BerylDB is free software: you can
# redistribute it and/or modify it under the terms of the BSD License
# version 3.
#
# More information about our licensing can be found at https://docs.beryl.dev

use v5.10.0;
use strict;
use warnings FATAL => qw(all);

use Cwd                   qw(getcwd);
use File::Basename        qw(basename);
use File::Copy            ();
use File::Spec::Functions qw(abs2rel catfile catdir rel2abs);
use FindBin               qw($RealDir);
use Getopt::Long          qw(GetOptions);
use POSIX                 qw(getgid getuid);

use lib $RealDir;

use make::utils;
use make::configure;
use make::brld;
use make::environment;

my ($set_binary_dir,
    $set_RealDir,
    $set_data_dir,
    $set_db_dir,
    $set_development,
    $set_disable_auto_extras,
    $set_disable_interactive,
    $set_distribution_label,
    $set_example_dir,
    $set_gid,
    $set_log_dir,
    $set_manual_dir,
    $set_module_dir,
    $set_portable,
    $set_prefix,
    $set_runtime_dir,
    $set_script_dir,
    $set_engine,
    $set_system,
    $set_uid);

sub list_extras ();

sub enable_extra_modules (@);

sub disable_extras (@);

my @option_enable_extras;
my @option_disable_extras;

exit 1 unless GetOptions(
	'clean'  => \&cmd_clean,
	'help'	 => \&cmd_help,
	'update' => \&cmd_update,

	'binary-dir=s'         => \$set_binary_dir,
	'config-dir=s'         => \$set_RealDir,
	'data-dir=s'           => \$set_data_dir,
	'db-dir=s'             => \$set_db_dir,
	'development'          => \$set_development,
	'disable-auto-extras'  => \$set_disable_auto_extras,
	'disable-interactive'  => \$set_disable_interactive,
	'distribution-label=s' => \$set_distribution_label,
	'example-dir=s'        => \$set_example_dir,
	'gid=s'                => \$set_gid,
	'log-dir=s'            => \$set_log_dir,
	'manual-dir=s'         => \$set_manual_dir,
	'module-dir=s'         => \$set_module_dir,
	'portable'             => \$set_portable,
	'prefix=s'             => \$set_prefix,
	'runtime-dir=s'        => \$set_runtime_dir,
	'script-dir=s'         => \$set_script_dir,
        'engine=s'             => \$set_engine,
	'system'               => \$set_system,
	'uid=s'                => \$set_uid,

	'disable-extras=s@' => \@option_disable_extras,
	'enable-extras=s@'  => \@option_enable_extras,
	'list-extras'       => sub { list_extras; exit 0; },
);

if (scalar(@option_enable_extras) + scalar(@option_disable_extras) > 0) 
{
	@option_enable_extras = grep { /\S/ } split /[, ]+/, join(',', @option_enable_extras);
	@option_disable_extras = grep { /\S/ } split /[, ]+/, join(',', @option_disable_extras);
	enable_extra_modules(@option_enable_extras);
	disable_extras(@option_disable_extras);
	list_extras;
	exit 0;
}

our $interactive_setup = !(
	!-t STDIN ||
	!-t STDOUT ||
	defined $set_binary_dir ||
	defined $set_RealDir ||
	defined $set_data_dir ||
	defined $set_development ||
	defined $set_disable_auto_extras ||
	defined $set_disable_interactive ||
	defined $set_distribution_label ||
	defined $set_example_dir ||
	defined $set_gid ||
	defined $set_log_dir ||
	defined $set_manual_dir ||
	defined $set_module_dir ||
	defined $set_portable ||
	defined $set_prefix ||
	defined $set_runtime_dir ||
	defined $set_script_dir ||
        defined $set_engine ||
	defined $set_system ||
	defined $set_uid
);

my %config;

my %version = get_version $set_distribution_label;

my $welcome = "Setting up BerylDB $version{FULL} for " . ucfirst($^O) . ".";

say brld_format "\n<|BOLD $welcome |>\n";

if ($interactive_setup) 
{
	%config = read_config_file(CONF_CACHEFILE);
	run_test abs2rel(CONF_CACHEFILE, $RealDir), %config;

	if (!defined $config{VERSION}) 
	{
		$config{VERSION} = CONFIGURE_CACHE_VERSION;
	} 
	elsif ($config{VERSION} != CONFIGURE_CACHE_VERSION) 
	{
		show_warning "ignoring contents of ${\CONF_CACHEFILE} as it was generated by an incompatible version of $0!";
		%config = ('VERSION', CONFIGURE_CACHE_VERSION);
	}
}

$config{CXX} = locate_compiler($config{CXX} // $ENV{CXX});

unless ($config{CXX}) 
{
	say 'Unable to find a C++ compiler';

	unless ($interactive_setup) 
	{
		say 'You must set the CXX environment to a valid C++ compiler.';
		exit 1;
	}
	
	until ($config{CXX}) 
	{
		my $compiler_path = prompt_string 1, 'You must specify a valid C++ compiler path:', 'c++';
		$config{CXX} = locate_compiler $compiler_path;
	}
}

my %compiler = retrieve_compiler($config{CXX});

my @engines;
push @engines, 'epoll'  if run_test 'epoll', test_header $config{CXX}, 'sys/epoll.h';
push @engines, 'kqueue' if run_test 'kqueue', verify_file $config{CXX}, 'kqueue.cpp';

if (defined $set_engine) 
{
        unless (grep { $_ eq $set_engine } @engines) 
        {
                my $reason = -f "src/engines/engine_$set_engine.cpp" ? 'was not located' : 'was not found';
                show_error "The engine you selected ($set_engine) $reason!",
                        'Available engines are:',
                        map { "  * $_" } @engines;
        }
}

$config{ENGINE} = $set_engine // $engines[0];

strict_test 'signal.h', test_header $config{CXX}, 'signal.h';
strict_test 'sys/resource.h', test_header $config{CXX}, 'sys/resource.h';
strict_test 'getopt.h', test_header $config{CXX}, 'getopt.h';
strict_test 'pwd.h',   test_header $config{CXX}, 'pwd.h';
strict_test 'math.h', test_header $config{CXX}, 'math.h';
strict_test 'dlfcn.h', test_header $config{CXX}, 'dlfcn.h';
strict_test 'stdlib.h', test_header $config{CXX}, 'stdlib.h';
strict_test 'netinet/tcp.h', test_header $config{CXX}, 'netinet/tcp.h';
strict_test 'dirent.h', test_header $config{CXX}, 'dirent.h';
strict_test 'unistd.h', test_header $config{CXX}, 'unistd.h';

$config{CLOCK_GETTIME_OK} = run_test 'clock_gettime()', verify_file($config{CXX}, 'clock_gettime.cpp', '-lrt -std=c++14');
$config{CORE_COUNT} = get_cpu_count();

if ($^O eq "freebsd")
{
        $config{ROCKS_OK} = run_test 'rocksdb', verify_file($config{CXX}, 'rocksdb.cpp', '-I/usr/local/include -L/usr/local/lib -lrocksdb');
}
else
{
        $config{ROCKS_OK} = run_test 'rocksdb', verify_file($config{CXX}, 'rocksdb.cpp', '-lrocksdb -std=c++14');

}

if (!$config{ROCKS_OK})
{
	show_warning "rocksdb is missing.";
        exit;
}
 
print "\n";
print_ok "Dependency test passed. BerylDB is now ready to be configured.\n";

$config{CORE_DIR} = getcwd();

if (defined $set_portable) 
{
	show_error '--portable and --system have a conflict and should be ran together.' if defined $set_system;
	$config{DESTDIR}     = catfile $RealDir, 'run', '';
	$config{BASE_DIR}    = $set_prefix      // '';
	$config{BINARY_DIR}  = $set_binary_dir  // 'bin';
	$config{CONFIG_DIR}  = $set_RealDir  // 'conf';
	$config{DATA_DIR}    = $set_data_dir    // 'data';
	$config{DB_DIR}      = $set_db_dir      // 'db';
	$config{EXAMPLE_DIR} = $set_example_dir // catdir $config{CONFIG_DIR}, 'examples';
	$config{LOG_DIR}     = $set_log_dir     // 'logs';
	$config{MANUAL_DIR}  = $set_manual_dir  // 'manuals';
	$config{MODULE_DIR}  = $set_module_dir  // 'modules';
	$config{RUNTIME_DIR} = $set_runtime_dir // $config{DATA_DIR};
	$config{SCRIPT_DIR}  = $set_script_dir  // $config{BASE_DIR};
} 
elsif (defined $set_system) 
{
	$config{BASE_DIR}    = $set_prefix      // '/';
	$config{BINARY_DIR}  = $set_binary_dir  // '/usr/sbin';
	$config{CONFIG_DIR}  = $set_RealDir  // '/etc/beryl';
	$config{DATA_DIR}    = $set_data_dir    // '/var/lib/beryl';
	$config{DB_DIR}      = $set_db_dir      // '/var/lib/db';
	$config{EXAMPLE_DIR} = $set_example_dir // '/usr/share/doc/beryl';
	$config{LOG_DIR}     = $set_log_dir     // '/var/log/beryl';
	$config{MANUAL_DIR}  = $set_manual_dir  // '/usr/share/man/man1';
	$config{MODULE_DIR}  = $set_module_dir  // '/usr/lib/beryl';
	$config{RUNTIME_DIR} = $set_runtime_dir // '/var/run';
	$config{SCRIPT_DIR}  = $set_script_dir  // '/usr/share/beryl';
} 
else 
{
	$config{BASE_DIR}    = rel2abs $set_prefix // $config{BASE_DIR}    // catdir $RealDir,            'run';
	$config{BINARY_DIR}  = $set_binary_dir     // $config{BINARY_DIR}  // catdir $config{BASE_DIR},   'bin';
	$config{CONFIG_DIR}  = $set_RealDir     // $config{CONFIG_DIR}  // catdir $config{BASE_DIR},   'conf';
	$config{DATA_DIR}    = $set_data_dir       // $config{DATA_DIR}    // catdir $config{BASE_DIR},   'data';
	$config{DB_DIR}      = $set_db_dir       // $config{DB_DIR}    // catdir $config{BASE_DIR},   'db';
	$config{EXAMPLE_DIR} = $set_example_dir    // $config{EXAMPLE_DIR} // catdir $config{CONFIG_DIR}, 'examples';
	$config{LOG_DIR}     = $set_log_dir        // $config{LOG_DIR}     // catdir $config{BASE_DIR},   'logs';
	$config{MANUAL_DIR}  = $set_manual_dir     // $config{MANUAL_DIR}  // catdir $config{BASE_DIR},   'manuals';
	$config{MODULE_DIR}  = $set_module_dir     // $config{MODULE_DIR}  // catdir $config{BASE_DIR},   'modules';
	$config{RUNTIME_DIR} = $set_runtime_dir    // $config{RUNTIME_DIR} // $config{DATA_DIR};
	$config{SCRIPT_DIR}  = $set_script_dir     // $config{SCRIPT_DIR}  // $config{BASE_DIR};
}

my @group;

if (defined $set_gid) 
{
	@group = $set_gid =~ /^\d+$/ ? getgrgid($set_gid) : getgrnam($set_gid);
	show_error "Gid '$set_gid' not found." unless @group;
} 
else 
{
	@group = $set_system ? getgrnam('beryl') : getgrgid($config{GID} // getgid());
	show_error "you need to specify a group to run as using '--gid [id|name]'!" unless @group;

	unless ($group[2]) 
	{
		show_warning <<"EOW";
You are trying to compile BerylDB on priviliged $group[0] group and it is not clear which
unprivileged group to run BerylDB as.

In order to solve this issue, you should create create a new
unprivileged user/group, which will allow you to build and run, you may also pass the '--gid [id|name]' flag thus
specifing what unprivileged group to run as.
EOW
		if (!prompt_bool $interactive_setup, "Are you sure you want to are going to build BerylDB in the $group[0] group?", 0) 
		{
			say STDERR "If you need to build BerylDB in the $group[0] group, you must pass the --gid $group[2] flag." unless $interactive_setup;
			exit 1;
		}
	}
}
$config{GROUP} = $group[0];
$config{GID}   = $group[2];

my @user;

if (defined $set_uid) 
{
	@user = $set_uid =~ /^\d+$/ ? getpwuid($set_uid) : getpwnam($set_uid);
	show_error "UID '$set_uid' not found in the system." unless @user;
} 
else 
{
	@user = $set_system ? getpwnam('beryl') : getpwuid($config{UID} // getuid());
	show_error "you need to specify a user to run as using '--uid [id|name]'!" unless @user;
	
	unless ($user[2]) 
	{
		show_warning <<"EOW";
You are trying to compile BerylDB on priviliged $user[0] user and have not specified
an unprivileged user to run BerylDB as.

In order to solve this issue, you should create create a new
unprivileged user/group, which will allow you to build and run, you may also pass the '--gid [id|name]' flag thus
specifing what unprivileged group to run as.
EOW
		if (!prompt_bool $interactive_setup, "Would you like to build as the $user[0] user?", 0) 
		{
			say STDERR "If you need to build BerylDB in the $group[0] group, you must pass the --gid $group[2] flag." unless $interactive_setup;
			exit 1;
		}
	}
}
$config{USER} = $user[0];
$config{UID}  = $user[2];

if (-e '/proc/user_beancounters' || -e '/proc/vz/vzaquota') 
{
	show_warning <<'EOW';
You are building BerylDB in an OpenVZ container. Keep in mind that if you desire
to build BerylDB in this VZ, you must make sure that the NTP is properly configured
on the hardware node.
EOW
}

if ($^V lt 'v5.26.0') 
{
	show_warning <<"EOW";
You are building BerylDB with Perl $^V. This version is not supported by Beryl.
Please consider updating to Perl v5.26 or newer.
EOW
}

my %future_compilers = (
	AppleClang => version->parse('10.0'),
	Clang      => version->parse('5.0'),
	GCC        => version->parse('7.0'),
);

if (exists $future_compilers{$compiler{NAME}} && $compiler{VERSION} lt $future_compilers{$compiler{NAME}}) 
{
	show_warning <<"EOW";
You are building BerylDB with $compiler{NAME} v$compiler{VERSION}. This compiter is
outdated and will not be supported by the next version of BerylDB. Please consider
updating to $compiler{NAME} v$future_compilers{$compiler{NAME}} or newer.
EOW
}

if (defined $version{REAL_LABEL}) 
{
	show_warning <<'EOW';
You are about to compile a beta (release candidate) version. A beta version contains
source code that has not been tested as extensively and may contain various issues.
EOW
	if (!prompt_bool $interactive_setup, 'Do you understand?', $set_development // 0) 
	{
		say STDERR 'If you accept this condition, you need to pass the --development flag.' unless $interactive_setup;
		exit 1;
	}
}

my $question = <<"EOQ";
\nBerylDB is configured with the following paths:

<|BOLD Binary:|> $config{BINARY_DIR}
<|BOLD Config:|> $config{CONFIG_DIR}
<|BOLD Data:|>   $config{DATA_DIR}
<|BOLD DB:|>     $config{DB_DIR}
<|BOLD Log:|>    $config{LOG_DIR}
<|BOLD Manual:|> $config{MANUAL_DIR}
<|BOLD Module:|> $config{MODULE_DIR}
<|BOLD Script:|> $config{SCRIPT_DIR}

Would you like to change these settings? (Recommended: no)
EOQ
if (prompt_bool $interactive_setup, $question, 0) 
{
	my $root_basedir = $config{BASE_DIR};
	$config{BASE_DIR} = interactive_dir $interactive_setup, 'Please choose a directory to install BerylDB', $config{BASE_DIR};
	
	for my $key (qw(BINARY_DIR CONFIG_DIR DB_DIR DATA_DIR LOG_DIR MANUAL_DIR MODULE_DIR SCRIPT_DIR)) 
	{
		$config{$key} =~ s/^\Q$root_basedir\E/$config{BASE_DIR}/;
	}
	
	$config{BINARY_DIR} = interactive_dir $interactive_setup, 'Choose a directory for the BerylDB binary', $config{BINARY_DIR};
	$config{CONFIG_DIR} = interactive_dir $interactive_setup, 'Choose a directory for configuration files', $config{CONFIG_DIR};
	$config{DATA_DIR}   = interactive_dir $interactive_setup, 'Choose a directory for data files', $config{DATA_DIR};
	$config{DB_DIR}     = interactive_dir $interactive_setup, 'Choose a directory for database files', $config{DB_DIR};
	$config{LOG_DIR}    = interactive_dir $interactive_setup, 'Choose a directory for log files',           $config{LOG_DIR};
	$config{MANUAL_DIR} = interactive_dir $interactive_setup, 'Choose a directory for manual files',        $config{MANUAL_DIR};
	$config{MODULE_DIR} = interactive_dir $interactive_setup, 'Choose a directory for module files',             $config{MODULE_DIR};
	$config{SCRIPT_DIR} = interactive_dir $interactive_setup, 'Choose a directory for scripts files',             $config{SCRIPT_DIR};
	$config{EXAMPLE_DIR} = $config{CONFIG_DIR} . '/examples';
	$config{RUNTIME_DIR} = $config{DATA_DIR};
}

$question = <<'EOQ';
BerylDB is configured to automatically enable all available extra modules.
Do you want to enable extra modules?
EOQ
say "\n";
if (prompt_bool $interactive_setup, $question, 0) 
{
	for my $extra (<$RealDir/src/modules/extra/m_*.cpp>) 
	{
		my $module_name = module_shrink $extra;
	
		if (prompt_bool $interactive_setup, "Would you like to enable the <|BOLD $module_name|> module?", 0) 
		{
			enable_extra_modules $module_name;
		}
	}
} 
elsif (!defined $set_disable_auto_extras) 
{
	my %modules = (

	);
	
	while (my ($module, $command) = each %modules) 
	{
		unless (defined $command && system "$command 1>/dev/null 2>/dev/null") 
		{
			enable_extra_modules $module;
		}
	}
}

$config{DISTRIBUTION} = $set_distribution_label if $set_distribution_label;

define_conf_cache %config;
process_make \%config, \%compiler, \%version;

print brld_format <<"EOM";

Configuration has finished. 
These are the settings you are building BerylDB with:

<|BOLD Compiler:|>\n
  <|GREEN Binary:|>  $config{CXX}
  <|GREEN Name:|>    $compiler{NAME}
  <|GREEN Version:|> $compiler{VERSION}

EOM

my $counter_extra = 0;

for my $file (<$RealDir/src/modules/m_*>)
{
	$counter_extra++ if -l $file;
}

if ($counter_extra gt 0)
{
print brld_format <<"EOM";
<|BOLD Extra Modules:|>\n
EOM
	for my $file (<$RealDir/src/modules/m_*>) 
	{
		say "  * ${\module_shrink $file}" if -l $file;
	}
}
else
{
	print_ok "No extra modules added.";
}



my @arguments;
push @arguments, "-C${\abs2rel $RealDir}" unless getcwd eq $RealDir;
push @arguments, "-j${\(get_cpu_count() + 1)}";

print brld_format <<"EOM";

<|BOLD Paths:|>\n
  <|GREEN Binary:|>  $config{BINARY_DIR}
  <|GREEN Config:|>  $config{CONFIG_DIR}
  <|GREEN Data:|>    $config{DATA_DIR}
  <|GREEN DB:|>      $config{DB_DIR}
  <|GREEN Example:|> $config{EXAMPLE_DIR}
  <|GREEN Log:|>     $config{LOG_DIR}
  <|GREEN Manual:|>  $config{MANUAL_DIR}
  <|GREEN Module:|>  $config{MODULE_DIR}
  <|GREEN Runtime:|> $config{RUNTIME_DIR}
  <|GREEN Script:|>  $config{SCRIPT_DIR}

<|GREEN Engine:|>   $config{ENGINE}
<|GREEN Execution Group:|> $config{GROUP} ($config{GID})
<|GREEN Execution User:|>  $config{USER} ($config{UID})

EOM

my $make_using = "make";

if ($^O eq "freebsd")
{
	$make_using = "gmake";
}

print brld_format <<"EOM";
Configure completed, in order to compile Beryl run: '<|GREEN $make_using ${\join ' ', @arguments} install|>'
EOM

sub list_extras () 
{
	use File::Spec;
	my $srcdir = File::Spec->catdir("src", "modules");
	my $abs_srcdir = File::Spec->rel2abs($srcdir);
	local $_;
	my $dd;
	opendir $dd, File::Spec->catdir($abs_srcdir, "extra") or die (File::Spec->catdir($abs_srcdir, "extra") . ": $!\n");
	my @extras = map { File::Spec->case_tolerant() ? lc($_) : $_ } (readdir($dd));
	closedir $dd;
	undef $dd;
	opendir $dd, $abs_srcdir or die "$abs_srcdir: $!\n";
	my @sources = map { File::Spec->case_tolerant() ? lc($_) : $_ } (readdir($dd));
	closedir $dd;
	undef $dd;
	my $maxlen = (sort { $b <=> $a } (map { length module_shrink $_ } (@extras)))[0];
	my %extras = ();
EXTRA:	for my $extra (@extras) 
{
		next if (File::Spec->curdir() eq $extra || File::Spec->updir() eq $extra);
		my $absolute_extra = File::Spec->catfile($abs_srcdir, "extra", $extra);
		my $abs_source = File::Spec->catfile($abs_srcdir, $extra);
		next unless ($extra =~ m/\.(cpp|h)$/ || (-d $absolute_extra)); 

		if (-l $abs_source) 
		{
			my $targ = readlink($abs_source);
			my $abs_targ = File::Spec->rel2abs($targ, $abs_srcdir);
		
			if ($abs_targ eq $absolute_extra) 
			{
				$extras{$extra} = "\e[32;1menabled\e[0m";
			} 
			else 
			{
				$extras{$extra} = sprintf("\e[31;1mwrong symlink target (%s)\e[0m", $abs_targ);
			}
		} 
		elsif (-e $abs_source) 
		{
			my ($devext, $inoext) = stat($absolute_extra);
			my ($devsrc, $inosrc, undef, $link_source) = stat($abs_source);
			
			if ($link_source > 1) 
			{
				if ($devsrc == $devext && $inosrc == $inoext) 
				{
					$extras{$extra} = "\e[32;1menabled\e[0m";
				} 
				else 
				{
					$extras{$extra} = sprintf("\e[31;1mwrong hardlink target (%d:%d)\e[0m", $devsrc, $inosrc);
				}
			} 
			else 
			{
				open my $extfd, "<", $absolute_extra;
				open my $srcfd, "<", $abs_source;
				local $/ = undef;
				
				if (scalar(<$extfd>) eq scalar(<$srcfd>)) 
				{
					$extras{$extra} = "\e[32;1menabled\e[0m";
				} 
				else 
				{
					$extras{$extra} = sprintf("\e[31;1mout of synch (re-copy)\e[0m");
				}
			}
		} 
		else 
		{
			$extras{$extra} = "\e[33;1mdisabled\e[0m";
		}
	}

	for my $extra (keys(%extras)) 
	{
		next unless $extras{$extra} =~ m/enabled/; 
		my $absolute_extra = File::Spec->catfile($abs_srcdir, "extra", $extra);
		my @deps = split /\s+/, get_environment($absolute_extra, 'ModDep', '');

		for my $dep (@deps) 
		{
			if (exists($extras{$dep})) 
			{
				my $ref = \$extras{$dep}; 
				
				if ($$ref !~ m/needed by/) 
				{
					if ($$ref =~ m/enabled/) 
					{
						$$ref .= " (needed by \e[32;1m$extra\e[0m";
					} 
					else 
					{
						$$ref =~ s/\e\[.*?m//g; 
						$$ref .= " (needed by \e[0;32;1;5m$extra\e[0;31;1;5m";
					}
				} 
				else 
				{
					if ($$ref =~ m/enabled/) 
					{
						$$ref .= ", \e[32;1m$extra\e[0m";
					} 
					else 
					{
						$$ref .= ", \e[0;32;1;5m$extra\e[0;31;1;5m";
					}
				}
			}
		}
	}

	for my $extra (sort {$a cmp $b} keys(%extras)) 
	{
		my $text = $extras{$extra};
	
		if ($text =~ m/needed by/ && $text !~ m/enabled/) 
		{
			printf "\e[31;1;5m%-*s = %s%s\e[0m\n", $maxlen, module_shrink($extra), $text, ($text =~ m/needed by/ ? ")" : "");
		} 
		else 
		{
			printf "%-*s = %s%s\n", $maxlen, module_shrink($extra), $text, ($text =~ m/needed by/ ? "\e[0m)" : "");
		}
	}

	return keys(%extras) if wantarray; 
}

sub enable_extra_modules(@) 
{
	my $mod_directory = catdir $RealDir, 'src', 'modules';
	my $extradir = catdir $mod_directory, 'extra';

	for my $extra (@_) 
	{
		my $real_name = module_shrink $extra;
		my $extrafile = module_fullpath $extra;

		my $extrapath = catfile $extradir, $extrafile;
		
		if (!-f $extrapath) 
		{
			show_error "<|GREEN $extra|> is not an extra module!";
		}

		my $module_path = catfile $mod_directory, $extrafile;

		if (-l $module_path) 
		{
			if (readlink($module_path) ne $extrapath) 
			{
				unlink $module_path; 
			} 
			else 
			{
				next; 
			}
		}

		if (-e $module_path) 
		{
			show_error "Unable to symlink <|GREEN ${\abs2rel $module_path}|> to <|GREEN ${\abs2rel $extrapath}|>: the target exists and is not a symlink.";
		} 
		else 
		{
			say brld_format "Enabling the <|GREEN $real_name|> module ...";
			symlink $extrapath, $module_path or show_error "unable to symlink <|GREEN ${\abs2rel $module_path}|> to <|GREEN ${\abs2rel $extrapath}|>: $!";
		}
	}
}

sub disable_extras(@) 
{
	my $mod_directory = catdir $RealDir, 'src', 'modules';
	my $extradir = catdir $mod_directory, 'extra';

	for my $extra (@_) 
	{
		my $real_name = module_shrink $extra;
		my $extrafile = module_fullpath $extra;

		my $module_path = catfile $mod_directory, $extrafile;
		my $extrapath = catfile $extradir, $extrafile;
	
		if (!-e $module_path && !-e $extrapath) 
		{
			show_error "<|GREEN $real_name|> module is not present.";
		} 
		elsif (!-e $module_path && -e $extrapath) 
		{
			show_error "<|GREEN $real_name|> module is not enabled.";
		} 
		elsif ((-e $module_path && !-e $extrapath) || !-l $module_path) 
		{
			show_error "<|GREEN $real_name|> module is not an extra module.";
		} 
		else 
		{
			say brld_format "Disabling <|GREEN $real_name|> module ...";
			unlink $module_path or show_error "unable to disable link <|GREEN $extrapath|>: $!";
		}
	}
}
